
[[exercises]]
name = "variables1"
path = "exercises/01_variables/variables1.rs"
mode = "compile"
hint = """
The declaration in the first line in the main function is missing a keyword
that is needed in Rust to create a new variable binding."""

[[exercises]]
name = "variables2"
path = "exercises/01_variables/variables2.rs"
mode = "compile"
hint = """
The compiler message is saying that Rust cannot infer the type that the
variable binding `x` has with what is given here.

What happens if you annotate the first line in the main function with a type
annotation?

What if you give `x` a value?

What if you do both?

What type should `x` be, anyway?

What if `x` is the same type as `10`? What if it's a different type?"""

[[exercises]]
name = "variables3"
path = "exercises/01_variables/variables3.rs"
mode = "compile"
hint = """
Oops! In this exercise, we have a variable binding that we've created on in the
first line in the `main` function, and we're trying to use it in the next line,
but we haven't given it a value.

We can't print out something that isn't there; try giving `x` a value!

This is an error that can cause bugs that's very easy to make in any
programming language -- thankfully the Rust compiler has caught this for us!"""

[[exercises]]
name = "variables4"
path = "exercises/01_variables/variables4.rs"
mode = "compile"
hint = """
In Rust, variable bindings are immutable by default. But here we're trying
to reassign a different value to `x`! There's a keyword we can use to make
a variable binding mutable instead."""

[[exercises]]
name = "variables5"
path = "exercises/01_variables/variables5.rs"
mode = "compile"
hint = """
In `variables4` we already learned how to make an immutable variable mutable
using a special keyword. Unfortunately this doesn't help us much in this
exercise because we want to assign a different typed value to an existing
variable. Sometimes you may also like to reuse existing variable names because
you are just converting values to different types like in this exercise.

Fortunately Rust has a powerful solution to this problem: 'Shadowing'!
You can read more about 'Shadowing' in the book's section 'Variables and
Mutability':
https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#shadowing

Try to solve this exercise afterwards using this technique."""

[[exercises]]
name = "variables6"
path = "exercises/01_variables/variables6.rs"
mode = "compile"
hint = """
We know about variables and mutability, but there is another important type of
variable available: constants.

Constants are always immutable and they are declared with keyword `const` rather
than keyword `let`.

Constants types must also always be annotated.

Read more about constants and the differences between variables and constants
under 'Constants' in the book's section 'Variables and Mutability':
https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#constants
"""

[[exercises]]
name = "primitive_types1"
path = "exercises/04_primitive_types/primitive_types1.rs"
mode = "compile"
hint = "No hints this time ;)"

[[exercises]]
name = "primitive_types5"
path = "exercises/04_primitive_types/primitive_types5.rs"
mode = "compile"
hint = """
Take a look at the 'Data Types -> The Tuple Type' section of the book:
https://doc.rust-lang.org/book/ch03-02-data-types.html#the-tuple-type
Particularly the part about destructuring (second to last example in the
section).

You'll need to make a pattern to bind `name` and `age` to the appropriate parts
of the tuple. You can do it!!"""

[[exercises]]
name = "primitive_types6"
path = "exercises/04_primitive_types/primitive_types6.rs"
mode = "test"
hint = """
While you could use a destructuring `let` for the tuple here, try
indexing into it instead, as explained in the last example of the
'Data Types -> The Tuple Type' section of the book:
https://doc.rust-lang.org/book/ch03-02-data-types.html#the-tuple-type
Now you have another tool in your toolbox!"""

